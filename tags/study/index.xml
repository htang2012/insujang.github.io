<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>study on Better Tomorrow with Computer Science</title>
    <link>https://insujang.github.io/tags/study/</link>
    <description>Recent content in study on Better Tomorrow with Computer Science</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 24 Aug 2020 09:21:00 +0900</lastBuildDate>
    
	<atom:link href="https://insujang.github.io/tags/study/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dynamic Kubelet Configuration</title>
      <link>https://insujang.github.io/2020-08-24/dynamic-kubelet-configuration/</link>
      <pubDate>Mon, 24 Aug 2020 09:21:00 +0900</pubDate>
      
      <guid>https://insujang.github.io/2020-08-24/dynamic-kubelet-configuration/</guid>
      <description>Kubelet, at launch time, loads configuration files from pre-specified files. Changed configurations are not applied into the running Kubelet process during runtime, hence manual restarting Kubelet is required after modification.
Dynamic Kubelet configuration eliminates this burden, making Kubelet monitors its configuration changes and restarts when it is updated1. It uses Kubernetes a ConfigMap object.
Kubelet Flags for Dynamic Configuration Dynamic kubelet configuration is not enabled by default. To be specific, one of required configurations is missing; the following flags for Kubelet are required for dynamic configuration:</description>
    </item>
    
    <item>
      <title>Introduction to Fedora Silverblue</title>
      <link>https://insujang.github.io/2020-07-15/fedora-silverblue/</link>
      <pubDate>Wed, 15 Jul 2020 12:35:00 +0900</pubDate>
      
      <guid>https://insujang.github.io/2020-07-15/fedora-silverblue/</guid>
      <description>Fedora Silverblue Fedora Silverblue 1 is an immutable desktop operating system based on Fedora Linux distribution. What immutable does mean is that most directories including rootfs (/) are mounted as read-only, and user applications run in an isolated execution environment. It is a part of Atomic Host project, and share the same underlying system with Fedora CoreOS (FCOS).
For this purpose, Fedora Silverblue adopted two technologies:
 libostree (OSTree) Flatpak  libostree 2 libostree (previously called OSTree) provides git-like model for managing bootable filesystem trees (binaries), along with for deploying them and managing the bootloader configuration.</description>
    </item>
    
    <item>
      <title>Go Modules: an Alternative to GOPATH for Package Distribution</title>
      <link>https://insujang.github.io/2020-04-04/go-modules/</link>
      <pubDate>Sat, 04 Apr 2020 19:27:00 +0900</pubDate>
      
      <guid>https://insujang.github.io/2020-04-04/go-modules/</guid>
      <description>This post introduces Go modules, introduced in Go version 1.11.
Go Modules? Go 1.11 introduces a new dependency mangement system, Go modules (That&amp;rsquo;s why Go uses the environment variable name GO111MODULE: indicating to use Go 1.11 module).
Google introduced Go module as an alternative to GOPATH for versioning and package distribution. At first I did not understand what does it means specifically. Here is my explanaion.
Importing Packages without Go Modules Go programmers can import third-party packages (i.</description>
    </item>
    
    <item>
      <title>Programming Kubernetes CRDs</title>
      <link>https://insujang.github.io/2020-02-13/programming-kubernetes-crd/</link>
      <pubDate>Thu, 13 Feb 2020 10:13:00 +0900</pubDate>
      
      <guid>https://insujang.github.io/2020-02-13/programming-kubernetes-crd/</guid>
      <description>In [previous post], I briefly introduced a custom resource definition and how to create it through CLI. In this post, I introduce how to implement Go code that programatically specifies a CRD and a custom controllers that handles CRD events.
Many tutorials are exist, but not perfect 1 2 3 4 [^tutorial4]. I by myself implement a new custom controller to fully understand how it works, and introduce almost full details here.</description>
    </item>
    
    <item>
      <title>Kubernetes Custom Resource Definition (CRD)</title>
      <link>https://insujang.github.io/2020-02-11/kubernetes-custom-resource/</link>
      <pubDate>Tue, 11 Feb 2020 17:23:00 +0900</pubDate>
      
      <guid>https://insujang.github.io/2020-02-11/kubernetes-custom-resource/</guid>
      <description>One of main advantages of Kubernetes API is flexibility; users can add a custom resource to the Kubernetes cluster, and Kubernetes apiserver manages defined custom resources like standard resources (e.g. ReplicaSet, etc). Main introduction in Kubernetes document is in [here].
A major confusing point comes from ambiguous distinction between Custom Resource Definition (CRD) and Aggregated APIserver (AA). Even the document explains some differences of two types of implementation, it is not clearly understandable.</description>
    </item>
    
    <item>
      <title>Introduction to Programming Infiniband RDMA</title>
      <link>https://insujang.github.io/2020-02-09/introduction-to-programming-infiniband/</link>
      <pubDate>Sun, 09 Feb 2020 19:58:00 +0900</pubDate>
      
      <guid>https://insujang.github.io/2020-02-09/introduction-to-programming-infiniband/</guid>
      <description>This post explains the basic of RDMA programming. There are many examples and posts regarding this, however, I personally could not find enough explanations for the examples. It was hard to understand how it works, and here I summarize what I got.
Backgrounds Channel Adapter (CA) Channel adapter refers an end node in the infiniband network. It is equivalent of Ethernet network interface card (NIC), but with more features regarding Infiniband and RDMA 1.</description>
    </item>
    
    <item>
      <title>Building Mellanox OFED from source code</title>
      <link>https://insujang.github.io/2020-01-25/building-mellanox-ofed-from-source/</link>
      <pubDate>Sat, 25 Jan 2020 10:28:00 +0900</pubDate>
      
      <guid>https://insujang.github.io/2020-01-25/building-mellanox-ofed-from-source/</guid>
      <description>Mellanox is a manufacturer of networking products based on infiniband, which in these days are used for Remote DMA (RDMA). Though their documents are explained and managed well in their [website], I cannot find how to build an infiniband device driver from source code they provide.
Building Mellanox OFED source code: inside install script Source code can be downloaded in [here]. Currently the latest version of MLNX_OFED is 4.7-3.2.9.0.
When you untar the archive, you can see SOURCES directory, which contains the following another archives.</description>
    </item>
    
    <item>
      <title>Generate a Self-signed Certificate</title>
      <link>https://insujang.github.io/2020-01-07/self-signed-certificate/</link>
      <pubDate>Tue, 07 Jan 2020 16:12:00 +0900</pubDate>
      
      <guid>https://insujang.github.io/2020-01-07/self-signed-certificate/</guid>
      <description>A self-signed certificate is a ceritificate, which is not signed by a certificate authority (CA) 1 2. (There is no parent-like CA when creating a CA, CA itself is a self-signed certificate.) When using Kubernetes, kubeadm automatically genereates a self-signed Kubernetes CA before generating other certificates.
Steps to create a certificate 3 Follow the steps to create a self-signed certificate:
 Generate a private key Generate a Certificate Signing Request (CSR) Generate a self-signed certificate  Generate a private key A generated certificate must be signed with the Certificate Authority&amp;rsquo;s private key, which we are going to make here.</description>
    </item>
    
    <item>
      <title>Kubernetes Authentication: Client Certificate</title>
      <link>https://insujang.github.io/2019-12-18/kubernetes-authentication/</link>
      <pubDate>Wed, 18 Dec 2019 09:26:00 +0900</pubDate>
      
      <guid>https://insujang.github.io/2019-12-18/kubernetes-authentication/</guid>
      <description>1
For access control, Kubernetes steps the procedures above for each API operation: authentication (who can access), authorization (what can be accessed), and admisssion control. This post is about Kubernetes authentication.
All API accesses are handled by Kubernetes api server. All accesses have to be authenticated by the API server for Kubernetes operations. Kubernetes API server serve on 2 ports: one for testing, and the other for all other cases. By default, these ports are:</description>
    </item>
    
    <item>
      <title>Cmake for Custom Library Build System in Go</title>
      <link>https://insujang.github.io/2019-12-10/cmake-for-custom-library-build-system-in-go/</link>
      <pubDate>Tue, 10 Dec 2019 15:04:00 +0900</pubDate>
      
      <guid>https://insujang.github.io/2019-12-10/cmake-for-custom-library-build-system-in-go/</guid>
      <description>In the previous post, I implemented a Go shim layer that enables c++ codes to use Go functionalities. This post dives a little bit deeper into CMake build system for this interaction.
The following CMakeLists.txt provides a binary compilation altogether with compiling Go based static library.
cmake_minimum_required(VERSION 3.0)project(test)set(TARGET_OUT test.out)set(TARGET_LIB test.lib)# Go configurations set(GO_SRCS test.go)set(GO_LIBNAME libtest.a)# Custom command for &amp;#39;go build -buildmode=c-archive ...&amp;#39; # to create a library from Go codes. add_custom_command(OUTPUT ${GO_LIBNAME} DEPENDS ${GO_SRCS} WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} COMMAND env go build -buildmode=c-archive -o &amp;#34;${CMAKE_CURRENT_BINARY_DIR}/${GO_LIBNAME}&amp;#34; ${CMAKE_GO_FLAGS} ${GO_SRCS} COMMENT &amp;#34;Building Go library&amp;#34;)# Add a custom target for the library.</description>
    </item>
    
  </channel>
</rss>